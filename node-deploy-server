#!/bin/sh
":" //# http://sambal.org/2014/02/passing-options-node-shebang-line/; exec /usr/bin/env node --harmony-async-await "$0" "$@"

const app = require('express')()
const path = require('path')
const GitHubApi = require('github')
const crypto = require('crypto')
const download = require('download')
const zip = require('adm-zip')
const fs = require('fs-extra')
const exec = require('child_process').exec
const debug = require('debug')('app')
const hostname = process.env.HOSTNAME || '127.0.0.1'
const port = process.env.PORT || 3000
const secret = process.env.SECRET || ''
const github = new GitHubApi({
  protocol: 'https',
  host: 'api.github.com',
  headers: {
    'user-agent': 'node-deploy-server'
  },
  Promise: require('bluebird'),
  followRedirects: false,
  timeout: 5000
})

app.use(require('body-parser').json())
app.use((req, res, next) => {
  const json = req.body
  const payload = JSON.stringify(json).replace(/[\u007F-\uFFFF]/g, chr => {
    return '\\u' + ('0000' + chr.charCodeAt(0).toString(16)).substr(-4)
  })
  const hex = crypto.createHmac('sha1', secret).update(payload, 'utf-8').digest('hex')
  const sha1 = `sha1=${hex}`

  debug(`incoming request: ${req.headers['x-hub-signature']}`)
  debug(`compare with ${sha1}`)
  debug(`here is your secret ${secret}`)

  if (sha1 !== req.headers['x-hub-signature']) {
    return res.sendStatus(403)
  }

  next()
})

app.post('/', async (req, res) => {
  const tag = req.body.tag
  const command = req.body.command
  const owner = req.body.owner
  const repo = req.body.repo
  const dist = req.body.dist

  if (owner && repo && dist) {
    const available = {}
    const githubTags = await github.repos.getTags({owner: owner, repo: repo})
    for (const githubTag of githubTags) {
      githubTag.name && (available[githubTag.name] = githubTag)
    }

    const newTag = Object.keys(available).sort().pop()
    if (newTag) {
      debug('tag founded!')
      const commit = (available[tag] || available[newTag])
      const tarTag = commit.name
      const tarBall = commit.zipball_url
      const sha = commit.commit.sha.substr(0, 7)
      const project = `${owner}-${repo}-${sha}/`
      const bak = `${dist}_${sha}_bak`
      const file = path.join(dist, path.basename(tarBall))
      const log = path.join(dist, '.node-deploy-server-log.json')
      const backlog = fs.existsSync(log) ? fs.readJsonSync(log, {throws: false}) : []

      if (backlog.indexOf(tarTag) !== -1 && !tag) {
        return res.sendStatus(200)
      } else {
        backlog.sort()
        const notFound = backlog.indexOf(tarTag) === -1
        notFound && backlog.push(tarTag)
        backlog.sort()
        const index = backlog.indexOf(tarTag)
        const length = notFound && backlog.length === 1 ? 0 : backlog.length
        backlog.splice(index + 1, length)
      }

      fs.existsSync(bak) && fs.removeSync(bak)
      fs.existsSync(dist) && fs.renameSync(dist, bak)

      try {
        debug('start downloading zipball')
        await download(tarBall, dist)
        const zipFile = new zip(file)
        const zipEntries = zipFile.getEntries();
        zipEntries.forEach(function(zipEntry) {
          const entry = zipEntry.rawEntryName.toString()
          if (entry !== project && !zipEntry.isDirectory) {
            const save = entry.split('/')
            save.shift()
            const real = path.join(dist, save.join('/'))
            fs.outputFile(real, zipEntry.getData().toString())
          }
        });

        if (command) {
          debug(command)
          exec(command, {cwd: dist});
        }

        debug('success!')
        fs.outputJsonSync(log, backlog)
        res.sendStatus(200)
      } catch (e) {
        debug('invalid request')
        fs.existsSync(dist) && fs.removeSync(dist)
        fs.existsSync(bak) && fs.renameSync(bak, dist)
        res.sendStatus(500)
      } finally {
        debug('request finished!')
        fs.existsSync(bak) && fs.removeSync(bak)
        fs.existsSync(file) && fs.removeSync(file)
      }
    }
  }
})

app.listen(port, hostname)
